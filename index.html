<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.5.57" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

<meta name="dcterms.date" content="2025-05-14" />

<title>ESS 330 Project Proposals</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<!-- htmldependencies:E3FAD763 -->
<script async src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <div id="quarto-toc-target"></div>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default toc-left">
  <div class="quarto-title-banner">
    <div class="quarto-title column-body">
      <h1 class="title">ESS 330 Project Proposals</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
            <div class="quarto-title-meta-author">
          <div class="quarto-title-meta-heading">Authors</div>
          <div class="quarto-title-meta-heading">Affiliation</div>
          
                <div class="quarto-title-meta-contents">
            <p class="author">Sarah Culhane </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        Colorado State University
                      </p>
                  </div>
                      <div class="quarto-title-meta-contents">
            <p class="author">Archer Goodman </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        Colorado State University
                      </p>
                  </div>
                      <div class="quarto-title-meta-contents">
            <p class="author">McKenna Cooper </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        Colorado State University
                      </p>
                  </div>
                    </div>
        
        <div class="quarto-title-meta">

                      
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">May 14, 2025</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      </div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header>

  

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#lakes-and-ponds-bring-the-boys-to-the-yard" id="toc-lakes-and-ponds-bring-the-boys-to-the-yard">Lakes and Ponds Bring The Boys to the Yard</a>
  <ul>
  <li><a href="#assessing-the-effect-of-riparian-zone-and-water-quality-on-taxonimic-richness" id="toc-assessing-the-effect-of-riparian-zone-and-water-quality-on-taxonimic-richness">Assessing the Effect of Riparian Zone and Water Quality on Taxonimic Richness</a></li>
  </ul></li>
  </ul>
</nav>
<section id="lakes-and-ponds-bring-the-boys-to-the-yard" class="level1">
<h1>Lakes and Ponds Bring The Boys to the Yard</h1>
<section id="assessing-the-effect-of-riparian-zone-and-water-quality-on-taxonimic-richness" class="level3">
<h3>Assessing the Effect of Riparian Zone and Water Quality on Taxonimic Richness</h3>
<p><strong>Introduction</strong></p>
<p>Throughout the mythologies of ancient civilizations, rivers are often portrayed as sacred lifelines and mystical forces that breathe life into the land. From the Nile of Egypt to the Ganges in India, rivers shaped the very foundation of human development. The route a river carves through a landscape not only guides the path of its water, but also dictates the types of vegetation that grow alongside it, the diversity of animals that depend on it, and the feasibility of long-term human settlement. The majority of the world’s great cities were born beside rivers, not merely for commerce, which could be achieved from any coast, but for one elemental advantage: rivers carry fresh water. Drinkable water. Or at least, they used to.</p>
<p>In today’s world, the demand for freshwater is greater than ever. Global population growth, expanding agricultural demands, urban sprawl, and climate change are placing unprecedented stress on aquatic ecosystems. Historically, human progress has been closely tied to our ability to manipulate the quantity of water available through irrigation systems, dams, aqueducts, and other technologies (citation?) But as environmental pressures grow, we are now forced to reckon with a second, equally critical dimension: water quality. Just as our ancestors learned to interpret the presence of certain plants and animals as signs of viable water sources, modern ecologists use biological indicators to evaluate the health of freshwater systems. Among the most widely used of these indicators are benthic macroinvertebrates; organisms that live on the bottom of rivers, lakes, and streams and include insects, crustaceans, mollusks, and worms. These organisms are uniquely valuable for biomonitoring due to their varied tolerance to pollutants, their limited mobility (which ties them to local conditions), and their life cycles, which span seasons or years( citation?) One particularly important group of macroinvertebrates used to indicate good water quality is the EPT taxa; Ephemeroptera (mayflies), Plecoptera (stoneflies), and Trichoptera (caddisflies). These taxa are generally sensitive to environmental disturbances, and their presence in high abundance is often correlated with clean, well-oxygenated water. In contrast, a dominance of more pollution-tolerant organisms such as oligochaete worms, leeches, and midge larvae (Chironomidae) is typically a sign of poor water quality and habitat degradation (<span class="citation" data-cites="McDonald_Mullins_Lewis_1991">McDonald, Mullins, and Lewis (<a href="#ref-McDonald_Mullins_Lewis_1991" role="doc-biblioref">1991</a>)</span>).</p>
<p>Species richness, especially for benthic macroinvertebrates, is influenced by multiple complex factors when it comes to water quality. But some of the most influential factors seem to be Ph, turbidity, dissolved oxygen, and temperature (citation?).</p>
<p>But water quality is not influenced solely by what occurs within the streambed. The surrounding environment, particularly riparian zones, plays a critical role. Riparian zones are the transitional areas between terrestrial and aquatic ecosystems, typically encompassing the vegetation and soils adjacent to rivers and streams. Though narrow in spatial extent, riparian zones provide disproportionate ecological benefits. They act as natural buffers, filtering out sediments, nutrients, and pollutants before they reach the water body. They also stabilize stream banks, reduce erosion, moderate water temperature through shading, and provide crucial habitat for a wide range of terrestrial and aquatic organisms. As such, the integrity of riparian zones is often used as a secondary, yet equally important, indicator of watershed health (<span class="citation" data-cites="Sabo2005">Sabo et al. (<a href="#ref-Sabo2005" role="doc-biblioref">2005</a>)</span>). Unfortunately, riparian zones are frequently the first casualties of human development. Agricultural expansion, urbanization, logging, and road construction often involve the removal or fragmentation of riparian vegetation. When riparian zones are degraded, their ability to support both terrestrial and aquatic biodiversity diminishes, and the systems they protect become more vulnerable to pollution, sedimentation, and thermal stress. Consequently, monitoring the type and abundance of riparian vegetation can yield valuable insights into the overall ecological condition of a watershed, and by extension, its capacity to support a diverse and healthy macroinvertebrate community.</p>
<p>With these connections in mind, our project seeks to investigate the relationship between riparian zone condition, water quality, and freshwater invertebrate diversity. Specifically, we aim to evaluate whether the composition and abundance of riparian plant cover is associated with the composition and abundance of benthic macroinvertebrates, with an emphasis on EPT taxa as indicators of ecosystem health. By exploring these patterns, we hope to contribute to a better understanding of how human land use and vegetation management practices may impact water quality through both direct and indirect ecological pathways.</p>
<p>To conduct this analysis, we will use data from the Klamath Network Lakes Monitoring Data Package (2013–2019), which includes biological and ecological monitoring data collected across three national parks: Crater Lake, Lassen Volcanic, and Redwood National Parks. From this dataset, we will focus on three specific tables: InvertSpecies.csv, which documents the abundance of macroinvertebrates at various sampling plots, RiparianCover.csv, which describes the vegetation characteristics of corresponding riparian zones, and WaterQuality.csv which includes data on physical and chemical water parameters at each sampling plot. Integrating this dataset will allow us to account for potential covariates or confounding variables that may influence macroinvertebrate populations independently of vegetation conditions. Using this data, we will assign a standardized “vegetation score” to each plot based on the amount of vegetation cover present, ranging from absent to very heavy. This score will serve as a proxy for riparian zone quality. We will then analyze the relationship between this vegetation score and macroinvertebrate diversity, particularly the presence of sensitive EPT taxa, using statistical methods in RStudio. To determine the strength and direction of relationships between variables, we will conduct a correlation test using a correlation heat map. To model the predictive influence of vegetation on macroinvertebrate abundance, we will use linear regression analysis. These statistical approaches will be complemented by clear and informative data visualizations created with ggplot2, including scatterplots, box plots, and bar graphs to communicate trends and variation across sites. This holistic approach will allow us to better interpret the ecological relationships we uncover and provide more robust insights into freshwater health within these protected park systems.</p>
<p><strong>Data Exploration</strong></p>
<p>All data for this project comes from the Klamath Lakes Monitoring Data Package 2013–2019, originally compiled by the U.S. Department of the Interior and now publicly available through Data.com. This dataset includes ecological monitoring records from Crater Lake National Park, Lassen Volcanic National Park, and Redwood National and State Park. However, for the purposes of our study, we will exclusively use data collected at Lassen Volcanic National Park, narrowing the geographic focus to improve consistency and data quality. The three files central to our analysis are InvertSpecies.csv, RiparianCover.csv, and WaterQuality.csv. These files contain complementary data and share key identifying columns, including Lake_Code, Start_Date, and Park_Name—which will allow us to merge the datasets and compare biological, physical, and vegetative conditions at each sampled water body.</p>
<p>The InvertSpecies file contains records of benthic macroinvertebrate communities sampled in lakes and ponds. It includes fields such as Taxon, Order, Count, and Life_Stage. For this study, we will focus on the orders Ephemeroptera (mayflies), Plecoptera (stoneflies), and Trichoptera (caddisflies), which are collectively known as EPT taxa. These macroinvertebrates are widely recognized as indicators of healthy freshwater ecosystems, as they are generally sensitive to pollution and habitat degradation. The RiparianCover file provides plot-level data on vegetation type and structure in riparian zones, such as Big_trees_ArealCover, Woody_shrubs_saplings_GroundCover, Canopy_Type, and Barren_AreaCcover. These variables will help us estimate the ecological integrity and potential human impact on surrounding shorelines. Each plot corresponds to a specific lake, allowing us to associate vegetation conditions with macroinvertebrate presence in those water bodies. The WaterQuality file offers insight into the abiotic conditions of each lake, including key measurements like Temperature_C, pH, Turbidity, Dissolved_oxygen, and Specific_conductivity. These parameters may contribute to or constrain macroinvertebrate diversity and could help contextualize any patterns observed between vegetation and aquatic biodiversity. While all three files have a relatively large number of rows (RiparianCover.csv: 1,680; InvertSpecies.csv: 3,299), some fields contain missing values, particularly with respect to sampling dates and environmental measurements. To account for this, we will filter for data collected in 2018, a year with strong representation across datasets, and group observations by plot. This will allow us to match vegetation conditions with corresponding macroinvertebrate counts and water quality measurements. From RiparianCover.csv, we are particularly interested in a subset of vegetation metrics that reflect both habitat structure and disturbance: Big_trees_ArealCover, Woody_shrubs_saplings_GroundCover, and Barren_ArealCover. These will form the basis of a vegetation condition score used later in the analysis. Meanwhile, from InvertSpecies.csv, we will extract insect counts and filter specifically for EPT taxa, which we define as “significantly present” when observed in quantities of at least 10 individuals per plot. Lastly, WaterQuality.csv will be used to examine physical and chemical characteristics of each lake. These variables will not only support broader ecological interpretations but also offer an additional layer of explanatory context for understanding macroinvertebrate patterns. By combining these three datasets with consistent identifiers and a focused temporal and spatial scope (Crater Lake, 2018), we can begin exploring the relationships among riparian cover, water quality, and macroinvertebrate biodiversity with clarity and coherence.</p>
<p><strong>Methods</strong></p>
<p>Our analysis focused on assessing the relationship between riparian vegetation characteristics, water quality, and the diversity of freshwater macroinvertebrates, especially EPT taxa (Ephemeroptera, Plecoptera, Trichoptera), in Lassen Volcanic National Park for the years 2013 and 2019. We began by loading three datasets: InvertSpecies.csv, RiparianCover.csv, and WaterQuality.csv, filtering each to include only observations from Lassen Volcanic National Park in the target years. Using shared identifiers (Lake_Code, Start_Date, Park_Name), we merged the datasets for each year to create two comprehensive data frames, one for 2013 and one for 2019.</p>
<p>To evaluate invertebrate community health, we first calculated taxa richness using the shannon diversity index. Then, we filtered the results to include just those in the EPT classification order to get a “score” representing EPT richness. Riparian vegetation quality was proxied through the categorical variable Barren_AreaCcover, which we converted into a numerical estimate of vegetative cover. We selected the 2013 dataset to build and evaluate a random forest regression model predicting EPT using water-quality and vegetation-related predictors: temperature in celsius, pH, dissolved oxygen, and estimated vegetative cover. Data was split into training and testing sets using initial_split(), and a cross-validation strategy (vfold_cv) was applied. We tuned model hyperparameters using tune_grid() and finalized the model based on RMSE performance. To visualize patterns and support interpretation, we generated several plots using ggplot2, including:</p>
<ul>
<li><p>Bar plots comparing insect order abundances by year</p></li>
<li><p>Boxplots of water quality metrics across years</p></li>
<li><p>A correlation heatmap to assess relationships between water quality parameters, EPT scores, and vegetation</p></li>
<li><p>A vegetation cover comparison plot between 2013 and 2019</p></li>
</ul>
<p>All analyses were conducted in RStudio using the tidymodels, tidyr, dplyr, and ggplot2, parsnip, vegan, and reshape2 packages.</p>
<p><strong>Results</strong></p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 3
  .metric .estimator .estimate
  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;
1 rmse    standard      0.133 
2 rsq     standard      0.998 
3 mae     standard      0.0296</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure>
<p><a href="index_files/figure-html/unnamed-chunk-1-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="index_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid" width="672" /></a></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure>
<p><a href="index_files/figure-html/unnamed-chunk-1-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="index_files/figure-html/unnamed-chunk-1-2.png" class="img-fluid" width="672" /></a></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure>
<p><a href="index_files/figure-html/unnamed-chunk-1-3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="index_files/figure-html/unnamed-chunk-1-3.png" class="img-fluid" width="672" /></a></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure>
<p><a href="index_files/figure-html/unnamed-chunk-1-4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="index_files/figure-html/unnamed-chunk-1-4.png" class="img-fluid" width="672" /></a></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure>
<p><a href="index_files/figure-html/unnamed-chunk-1-5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5"><img src="index_files/figure-html/unnamed-chunk-1-5.png" class="img-fluid" width="672" /></a></p>
</figure>
</div>
</div>
</div>
<p><strong>Discussion</strong></p>
<p>Results suggest that there was an overall decline in macroinvertebrate taxa richness across all orders between 2013 and 2019 in water bodies within Lassen Volcanic National Park. The strong positive correlation between pH, dissolved oxygen, and EPT_score suggests that the decline in pH and dissolved oxygen present in those water bodies may have been partially responsible for the decline in taxa richness. Vegetation present in riparian zones within the park seemed to have increased, according to our analysis, and veg_cover and EPT_score seem to have a negative correlation. This suggests that as vegetation cover increased, taxa richness decreased, which goes against our hypothesis that more riparian cover would lead to high taxa richness. The cause of this is unknown and warrants further research. Going forward, more focused research and data collection needs to be done to find the source of pollution in Lassen Volcanic National Park so that measures can be taken to combat pollution at the source and improve the water quality of water bodies within the park. Limitations of our analysis include the fact that there was a lot of cleaning that had to be done in our dataset, and there was a disproportionate amount of data for each of the national parks and years that data was collected, with some parks and years having significantly more data than others. Crater Lake National Park especially had less data than both Volcanic National Park and Redwood National State Park.</p>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-McDonald_Mullins_Lewis_1991" class="csl-entry" role="listitem">
McDonald, Brook S., Gary W. Mullins, and Stuart Lewis. 1991. <span>“Macroinvertebrates as Indicators of Stream Health.”</span> <em>The American Biology Teacher</em> 53 (8): 462–66. <a href="https://doi.org/10.2307/4449370">https://doi.org/10.2307/4449370</a>.
</div>
<div id="ref-Sabo2005" class="csl-entry" role="listitem">
Sabo, John L., Ryan Sponseller, Mark Dixon, Kris Gade, Tamara Harms, Jim Heffernan, Andrea Jani, et al. 2005. <span>“RIPARIAN ZONES INCREASE REGIONAL SPECIES RICHNESS BY HARBORING DIFFERENT, NOT MORE, SPECIES.”</span> <em>Ecology</em> 86 (1): 56–62. https://doi.org/<a href="https://doi.org/10.1890/04-0668">https://doi.org/10.1890/04-0668</a>.
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id = "quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"openEffect":"zoom","loop":false,"selector":".lightbox","descPosition":"bottom","closeEffect":"zoom"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>

</body>

</html>
